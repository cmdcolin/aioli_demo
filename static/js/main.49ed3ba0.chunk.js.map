{"version":3,"sources":["layout.js","App.js","reportWebVitals.js","index.js"],"names":["minSizeToBotherWith","maxFeaturePitchWidth","LayoutRow","rowNumber","this","padding","sizeLimit","msg","console","log","data","allFilled","x","undefined","min","max","offset","bits","left","right","maxX","Math","getItemAt","rectWidth","Array","rect","l","r","initialize","currLength","length","additionalLength","warn","concat","oLeft","oRight","leftTrimAmount","rightTrimAmount","slice","trimAmount","floor","splice","desiredLength","GranularRectLayout","args","pitchX","pitchY","displayMode","round","bitmap","rectangles","maxHeight","ceil","Infinity","pTotalHeight","id","height","storedRec","top","_addRectToBitmap","pLeft","pRight","pHeight","rectangle","mX","h","maxTop","_collides","maxY","y","row","isRangeClear","av","_autovivifyRow","yEnd","setAllFilled","addRect","discardRange","pY","pX","parseLocString","locString","split","refId","start","end","width","snpcovheight","App","ref","useRef","fileRef","snpcovref","useQueryParams","loc","withDefault","StringParam","file","params","setParams","useState","readData","setReadData","mpileupData","setMPileupData","samtools","setSamtools","bamFile","setBamFile","setFile","setLoc","error","setError","forceUpdate","setTick","useCallback","tick","useForceUpdate","files","setFiles","useEffect","a","tool","Aioli","init","bamIdx","name","endsWith","mount","bam","Number","url","URL","window","location","fasta","exec","path","d","ctx","current","getContext","clearRect","parsedLoc","bpPerPx","layout","stdout","stderr","filter","f","forEach","index","flagString","startString","CIGAR","flags","cigarOps","i","len","op","fillStyle","leftPx","fillRect","numReads","fillText","onSubmit","event","preventDefault","htmlFor","type","value","style","minWidth","onChange","target","multiple","className","color","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.49ed3ba0.chunk.js","sourcesContent":["// minimum excess size of the array at which we garbage collect\nconst minSizeToBotherWith = 10000;\nconst maxFeaturePitchWidth = 200000;\n\n// a single row in the layout\nclass LayoutRow {\n  constructor(rowNumber) {\n    this.rowNumber = rowNumber;\n    this.padding = 1;\n    this.sizeLimit = 10000000;\n\n    // this.offset is the offset of the bits array relative to the genomic coordinates\n    //      (modified by pitchX, but we don't know that in this class)\n    // this.bits is the array of items in the layout row, indexed by (x - this.offset)\n    // this.min is the leftmost edge of all the rectangles we have in the layout\n    // this.max is the rightmost edge of all the rectangles we have in the layout\n  }\n\n  log(msg) {\n    //if (this.rowNumber === 0)\n    console.log(`r${this.rowNumber}: ${msg}`);\n  }\n\n  setAllFilled(data) {\n    this.allFilled = data;\n  }\n\n  getItemAt(x) {\n    if (this.allFilled) return this.allFilled;\n    // return (\n    //     this.min !== undefined &&\n    //     x >= this.min &&\n    //     x <= this.max &&\n    //     this.bits[x - this.min]\n    // )\n\n    if (this.min === undefined) return undefined;\n    if (x < this.min) return undefined;\n    if (x >= this.max) return undefined;\n    const offset = x - this.offset;\n    // if (offset < 0)\n    //     debugger\n    // if (offset >= this.bits.length)\n    //     debugger\n    return this.bits[offset];\n  }\n\n  isRangeClear(left, right) {\n    if (this.allFilled) return false;\n\n    if (this.min === undefined) return true;\n\n    if (right <= this.min || left >= this.max) return true;\n\n    // TODO: check right and middle before looping\n    const maxX = Math.min(this.max, right);\n    let x = Math.max(this.min, left);\n    for (; x < right && x < maxX; x += 1) if (this.getItemAt(x)) return false;\n\n    return true;\n  }\n\n  initialize(left, right) {\n    // NOTE: this.min, this.max, and this.offset are interbase coordinates\n    const rectWidth = right - left;\n    this.offset = left - rectWidth;\n    this.min = left;\n    this.max = right;\n    this.bits = new Array(right - left + 2 * rectWidth);\n    // this.log(`initialize ${this.min} - ${this.max} (${this.bits.length})`)\n  }\n\n  addRect(rect, data) {\n    const left = rect.l;\n    const right = rect.r + this.padding; // only padding on the right\n\n    // initialize if necessary\n    if (this.min === undefined) {\n      this.initialize(left, right);\n    } else {\n      // or check if we need to expand to the left and/or to the right\n\n      // expand rightward by the feature length + whole current length if necessary\n      const currLength = this.bits.length;\n\n      if (right - this.offset >= this.bits.length) {\n        const additionalLength =\n          right - this.offset - this.bits.length + 1 + this.bits.length;\n        if (this.bits.length + additionalLength > this.sizeLimit) {\n          console.warn(\n            `Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.`\n          );\n          this.initialize(left, right);\n        } else if (additionalLength > 0) {\n          this.bits = this.bits.concat(new Array(additionalLength));\n          // this.log(`expand right (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n        }\n      }\n\n      // expand by 2x leftward if necessary\n      if (left < this.offset) {\n        const additionalLength = this.offset - left + currLength;\n        if (this.bits.length + additionalLength > this.sizeLimit) {\n          console.warn(\n            `Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.`\n          );\n          this.initialize(left, right);\n        } else {\n          this.bits = new Array(additionalLength).concat(this.bits);\n          this.offset -= additionalLength;\n          // this.log(`expand left (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n        }\n      }\n    }\n\n    // set the bits in the bitmask\n    const oLeft = left - this.offset;\n    const oRight = right - this.offset;\n    // if (oLeft < 0) debugger\n    // if (oRight < 0) debugger\n    // if (oRight <= oLeft) debugger\n    // if (oRight > this.bits.length) debugger\n    if (oRight - oLeft > maxFeaturePitchWidth) {\n      console.warn(\n        `Layout X pitch set too low, feature spans ${\n          oRight - oLeft\n        } bits in a single row.`,\n        rect,\n        data\n      );\n    }\n\n    for (let x = oLeft; x < oRight; x += 1) {\n      //if (this.bits[x] && this.bits[x].get('name') !== data.get('name')) debugger\n      this.bits[x] = data;\n    }\n\n    if (left < this.min) this.min = left;\n    if (right > this.max) this.max = right;\n    //// this.log(`added ${leftX} - ${rightX}`)\n  }\n\n  /**\n   *  Given a range of interbase coordinates, deletes all data dealing with that range\n   */\n  discardRange(left, right) {\n    if (this.allFilled) return; // allFilled is irrevocable currently\n\n    // if we have no data, do nothing\n    if (!this.bits) return;\n\n    // if doesn't overlap at all, do nothing\n    if (right <= this.min || left >= this.max) return;\n\n    // if completely encloses range, discard everything\n    if (left <= this.min && right >= this.max) {\n      this.min = undefined;\n      this.max = undefined;\n      this.bits = undefined;\n      this.offset = undefined;\n      return;\n    }\n\n    // if overlaps left edge, adjust the min\n    if (right > this.min && left <= this.min) {\n      this.min = right;\n    }\n\n    // if overlaps right edge, adjust the max\n    if (left < this.max && right >= this.max) {\n      this.max = left;\n    }\n\n    // now trim the left, right, or both sides of the array\n    if (\n      this.offset < this.min - minSizeToBotherWith &&\n      this.bits.length > this.max + minSizeToBotherWith - this.offset\n    ) {\n      // trim both sides\n      const leftTrimAmount = this.min - this.offset;\n      const rightTrimAmount = this.bits.length - 1 - (this.max - this.offset);\n      // if (rightTrimAmount <= 0) debugger\n      // if (leftTrimAmount <= 0) debugger\n      // this.log(`trim both sides, ${leftTrimAmount} from left, ${rightTrimAmount} from right`)\n      this.bits = this.bits.slice(\n        leftTrimAmount,\n        this.bits.length - rightTrimAmount\n      );\n      this.offset += leftTrimAmount;\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    } else if (this.offset < this.min - minSizeToBotherWith) {\n      // trim left side\n      const desiredOffset = this.min - Math.floor(minSizeToBotherWith / 2);\n      const trimAmount = desiredOffset - this.offset;\n      // this.log(`trim left side by ${trimAmount}`)\n      this.bits.splice(0, trimAmount);\n      this.offset += trimAmount;\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    } else if (\n      this.bits.length >\n      this.max - this.offset + minSizeToBotherWith\n    ) {\n      // trim right side\n      const desiredLength =\n        this.max - this.offset + 1 + Math.floor(minSizeToBotherWith / 2);\n      // this.log(`trim right side by ${this.bits.length-desiredLength}`)\n      // if (desiredLength > this.bits.length) debugger\n      this.bits.length = desiredLength;\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    }\n\n    // if (this.offset > this.min) debugger\n    // if (this.bits.length <= this.max - this.offset) debugger\n\n    // if range now enclosed in the new bounds, loop through and clear the bits\n    const oLeft = Math.max(this.min, left) - this.offset;\n    // if (oLeft < 0) debugger\n    // if (oLeft >= this.bits.length) debugger\n    // if (oRight < 0) debugger\n    // if (oRight >= this.bits.length) debugger\n\n    const oRight = Math.min(right, this.max) - this.offset;\n    for (let x = oLeft; x >= 0 && x < oRight; x += 1) {\n      this.bits[x] = undefined;\n    }\n  }\n}\n\nexport default class GranularRectLayout {\n  /**\n   * @param args.pitchX  layout grid pitch in the X direction\n   * @param args.pitchY  layout grid pitch in the Y direction\n   * @param args.maxHeight  maximum layout height, default Infinity (no max)\n   */\n  constructor(args = {}) {\n    this.pitchX = args.pitchX || 5;\n    this.pitchY = args.pitchY || 3;\n\n    this.displayMode = args.displayMode;\n\n    // reduce the pitchY to try and pack the features tighter\n    if (this.displayMode === \"compact\") {\n      this.pitchY = Math.round(this.pitchY / 4) || 1;\n      this.pitchX = Math.round(this.pitchX / 4) || 1;\n    }\n\n    // console.log(`pitch: ${this.pitchX} / ${this.pitchY}`)\n\n    this.bitmap = [];\n    this.rectangles = {};\n    this.maxHeight = Math.ceil((args.maxHeight || Infinity) / this.pitchY);\n    this.pTotalHeight = 0; // total height, in units of bitmap squares (px/pitchY)\n  }\n\n  /**\n   * @returns {Number} top position for the rect, or Null if laying out the rect would exceed maxHeight\n   */\n  addRect(id, left, right, height, data) {\n    // if we have already laid it out, return its layout\n    if (id in this.rectangles) {\n      const storedRec = this.rectangles[id];\n      if (storedRec.top === null) return null;\n\n      // add it to the bitmap again, since that bitmap range may have been discarded\n      this._addRectToBitmap(storedRec, data);\n      return storedRec.top * this.pitchY;\n    }\n\n    const pLeft = Math.floor(left / this.pitchX);\n    const pRight = Math.floor(right / this.pitchX);\n    const pHeight = Math.ceil(height / this.pitchY);\n\n    const midX = Math.floor((pLeft + pRight) / 2);\n    const rectangle = { id, l: pLeft, r: pRight, mX: midX, h: pHeight };\n    if (data) rectangle.data = data;\n\n    const maxTop = this.maxHeight - pHeight;\n    let top = 0;\n    for (; top <= maxTop; top += 1) {\n      if (!this._collides(rectangle, top)) break;\n    }\n\n    if (top > maxTop) {\n      rectangle.top = top = null;\n      this.rectangles[id] = rectangle;\n      this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight);\n      return null;\n    }\n    rectangle.top = top;\n    this._addRectToBitmap(rectangle, data);\n    this.rectangles[id] = rectangle;\n    this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight);\n    // console.log(`G2 ${data.get('name')} ${top}`)\n    return top * this.pitchY;\n  }\n\n  _collides(rect, top) {\n    if (this.displayMode === \"collapsed\") return false;\n\n    const bitmap = this.bitmap;\n    // var mY = top + rect.h/2; // Y midpoint: ( top+height  + top ) / 2\n\n    // test exhaustively\n    const maxY = top + rect.h;\n    for (let y = top; y < maxY; y += 1) {\n      const row = bitmap[y];\n      if (row && !row.isRangeClear(rect.l, rect.r)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * make a subarray if it does not exist\n   * @private\n   */\n  _autovivifyRow(bitmap, y) {\n    let row = bitmap[y];\n    if (!row) {\n      row = new LayoutRow(y);\n      bitmap[y] = row;\n    }\n    return row;\n  }\n\n  _addRectToBitmap(rect, data) {\n    if (rect.top === null) return;\n\n    data = data || true;\n    const bitmap = this.bitmap;\n    const av = this._autovivifyRow;\n    const yEnd = rect.top + rect.h;\n    if (rect.r - rect.l > maxFeaturePitchWidth) {\n      // the rect is very big in relation to the view size, just\n      // pretend, for the purposes of layout, that it extends\n      // infinitely.  this will cause weird layout if a user\n      // scrolls manually for a very, very long time along the\n      // genome at the same zoom level.  but most users will not\n      // do that.  hopefully.\n      for (let y = rect.top; y < yEnd; y += 1) {\n        av(bitmap, y).setAllFilled(data);\n      }\n    } else {\n      for (let y = rect.top; y < yEnd; y += 1) {\n        av(bitmap, y).addRect(rect, data);\n      }\n    }\n  }\n\n  /**\n   *  Given a range of X coordinates, deletes all data dealing with\n   *  the features.\n   */\n  discardRange(left, right) {\n    // console.log( 'discard', left, right );\n    const pLeft = Math.floor(left / this.pitchX);\n    const pRight = Math.floor(right / this.pitchX);\n    const bitmap = this.bitmap;\n    for (let y = 0; y < bitmap.length; y += 1) {\n      const row = bitmap[y];\n      if (row) row.discardRange(pLeft, pRight);\n    }\n  }\n\n  hasSeen(id) {\n    return !!this.rectangles[id];\n  }\n\n  getByCoord(x, y) {\n    const pY = Math.floor(y / this.pitchY);\n    const row = this.bitmap[pY];\n    if (!row) return undefined;\n    const pX = Math.floor(x / this.pitchX);\n    return row.getItemAt(pX);\n  }\n\n  getByID(id) {\n    const r = this.rectangles[id];\n    if (r) {\n      return r.data || true;\n    }\n    return undefined;\n  }\n\n  cleanup() {}\n\n  getTotalHeight() {\n    return this.pTotalHeight * this.pitchY;\n  }\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { Aioli } from \"@biowasm/aioli\";\nimport GranularRectLayout from \"./layout\";\nimport { StringParam, useQueryParams, withDefault } from \"use-query-params\";\n\nfunction parseLocString(locString) {\n  const [refId, rest] = locString.split(\":\");\n  const [start, end] = rest.split(\"-\");\n  return { refId: +refId - 1, start: +start, end: +end };\n}\n\nexport function parseCigar(cigar) {\n  return (cigar || \"\").split(/([MIDNSHPX=])/);\n}\n\n// because we are using use-query-params without a router\nexport function useForceUpdate() {\n  const [, setTick] = useState(0);\n  const update = useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n  return update;\n}\n\nconst featHeight = 10;\nconst width = 1800;\nconst height = 1000;\nconst snpcovheight = 100;\nconst initialLoc = \"1:20000-40000\";\nconst initialFile =\n  \"https://s3.amazonaws.com/1000genomes/phase3/data/HG00096/alignment/HG00096.mapped.ILLUMINA.bwa.GBR.low_coverage.20120522.bam\";\n\nfunction App() {\n  const ref = useRef();\n  const fileRef = useRef();\n  const snpcovref = useRef();\n  const [params, setParams] = useQueryParams({\n    loc: withDefault(StringParam, initialLoc),\n    file: withDefault(StringParam, initialFile),\n  });\n  const [readData, setReadData] = useState();\n  const [mpileupData, setMPileupData] = useState();\n  const [samtools, setSamtools] = useState();\n  const [bamFile, setBamFile] = useState();\n  const [file, setFile] = useState(params.file);\n  const [loc, setLoc] = useState(params.loc);\n  const [error, setError] = useState();\n  const forceUpdate = useForceUpdate();\n  const [files, setFiles] = useState();\n\n  // this block initializes the samtools tool on Aioli\n  useEffect(() => {\n    (async () => {\n      const tool = new Aioli(\"samtools/1.10\");\n      await tool.init();\n      setSamtools(tool);\n    })();\n  }, []);\n\n  // this block \"mounts\" the BAM file on the Aioli FS\n  useEffect(() => {\n    (async () => {\n      // wait on \"samtools\" being initialized even though \"samtools\" is not\n      // used here, because it must mount something internally in the\n      // Aioli/samtools interface\n      if (samtools) {\n        if (files) {\n          let bamIdx =\n            files[0].name.endsWith(\"bam\") || files[0].name.endsWith(\"cram\")\n              ? 0\n              : 1;\n\n          const bam = await Aioli.mount(files[bamIdx]);\n          await Aioli.mount(files[Number(!bamIdx)]);\n          setBamFile(bam);\n        } else {\n          const url = new URL(params.file, window.location);\n          const bam = await Aioli.mount(`${url}`);\n          if (params.file.endsWith(\"bam\")) {\n            await Aioli.mount(`${url}.bai`);\n          } else if (params.file.endsWith(\"cram\")) {\n            await Aioli.mount(`${url}.crai`);\n          }\n\n          setBamFile(bam);\n        }\n      }\n    })();\n  }, [params.file, samtools, params.fasta, files]);\n\n  // this block performs a `samtools view` query\n  useEffect(() => {\n    (async () => {\n      if (bamFile && samtools) {\n        const d = await samtools.exec(`view ${bamFile.path} ${params.loc}`);\n        setReadData(d);\n      }\n    })();\n  }, [bamFile, params.loc, samtools]);\n\n  // this block performs a `samtools mpileup` query\n  useEffect(() => {\n    (async () => {\n      if (bamFile && samtools) {\n        const d = await samtools.exec(\n          `mpileup -r ${params.loc} ${bamFile.path}`\n        );\n        setMPileupData(d);\n      }\n    })();\n  }, [bamFile, params.loc, samtools]);\n\n  // this block draws the rectangles\n  useEffect(() => {\n    const ctx = ref.current.getContext(\"2d\");\n    ctx.clearRect(0, 0, width, height);\n    const parsedLoc = parseLocString(params.loc);\n    const bpPerPx = width / (parsedLoc.end - parsedLoc.start);\n    const layout = new GranularRectLayout();\n    if (readData && !readData.stdout) {\n      setError(readData.stderr);\n    }\n    readData?.stdout\n      .split(\"\\n\")\n      .filter((f) => !!f)\n      .forEach((row, index) => {\n        const [, flagString, , startString, , CIGAR] = row.split(\"\\t\");\n        const start = +startString - 1;\n        const flags = +flagString;\n        const cigarOps = parseCigar(CIGAR);\n        let length = 0;\n        for (let i = 0; i < cigarOps.length; i += 2) {\n          const len = +cigarOps[i];\n          const op = cigarOps[i + 1];\n          if (op !== \"I\" && op !== \"S\" && op !== \"H\") {\n            length += len;\n          }\n        }\n        if (flags & 16) {\n          ctx.fillStyle = \"#99f\";\n        } else {\n          ctx.fillStyle = \"#f99\";\n        }\n\n        const end = start + length;\n        const leftPx = (start - parsedLoc.start) * bpPerPx;\n        const width = (end - start) * bpPerPx;\n        const y = layout.addRect(index, start, end, featHeight);\n\n        ctx.fillRect(leftPx, y, width, featHeight);\n      });\n  }, [readData, params.loc]);\n\n  // this block draws the rectangles\n  useEffect(() => {\n    const ctx = snpcovref.current.getContext(\"2d\");\n    ctx.clearRect(0, 0, width, snpcovheight);\n    const parsedLoc = parseLocString(params.loc);\n    const bpPerPx = width / (parsedLoc.end - parsedLoc.start);\n    let maxHeight = 0;\n    if (mpileupData) {\n      mpileupData.stdout.split(\"\\n\").forEach((row) => {\n        const [, , , numReadsString] = row.split(\"\\t\");\n        const numReads = +numReadsString;\n        maxHeight = Math.max(maxHeight, numReads || 0);\n      });\n      mpileupData.stdout.split(\"\\n\").forEach((row) => {\n        const [, startString, , numReadsString] = row.split(\"\\t\");\n        const start = +startString - 1;\n        const numReads = +numReadsString;\n        const leftPx = (start - parsedLoc.start) * bpPerPx;\n        const end = start + 1;\n        const width = (end - start) * bpPerPx;\n\n        ctx.fillStyle = \"#ccc\";\n        const h = (numReads / maxHeight) * snpcovheight;\n        ctx.fillRect(leftPx, snpcovheight - h, width + 0.9, h);\n      });\n      ctx.fillStyle = \"black\";\n      ctx.fillText(`[0, ${maxHeight}]`, 0, 20);\n    }\n  }, [mpileupData, params.loc]);\n\n  return (\n    <div>\n      <p>\n        Enter BAM/CRAM file and location. This app uses @biowasm/aioli's\n        packaging of samtools to run samtools view and samtools mpileup\n      </p>\n      <form\n        onSubmit={(event) => {\n          setParams({ file, loc });\n          if (fileRef.current.files.length) {\n            setFiles(fileRef.current.files);\n          }\n          setMPileupData();\n          setReadData();\n          setError();\n          forceUpdate();\n          event.preventDefault();\n        }}\n      >\n        <label htmlFor=\"url\">URL: </label>\n        <input\n          id=\"url\"\n          type=\"text\"\n          value={file}\n          style={{ minWidth: \"75%\" }}\n          onChange={(event) => setFile(event.target.value)}\n        />\n        <br />\n        <label htmlFor=\"file\">File (import both BAM and BAI): </label>\n        <input id=\"file\" ref={fileRef} type=\"file\" multiple=\"multiple\" />\n\n        <br />\n        <label htmlFor=\"loc\">Location: </label>\n        <input\n          id=\"loc\"\n          type=\"text\"\n          value={loc}\n          onChange={(event) => setLoc(event.target.value)}\n        />\n        <button type=\"submit\">Submit</button>\n      </form>\n      {!readData ? <div className=\"dots\">Loading...</div> : null}\n      {error ? <div style={{ color: \"red\" }}>{error}</div> : null}\n      <canvas ref={snpcovref} width={width} height={snpcovheight} />\n      <canvas ref={ref} width={width} height={height} />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { QueryParamProvider } from \"use-query-params\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <QueryParamProvider>\n      <App />\n    </QueryParamProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}